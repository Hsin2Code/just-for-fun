* LISP学习
核心价值观：与其把功能写死，不如传进去一个函数参数。
[[link][https://zh.wikibooks.org/wiki/Lisp_%E5%85%A5%E9%96%80]]
** 第一章 函数
** 第二章 表、CAR、CDR
*** CAR 操作符 （别名 first）
CAR操作符的作用是取出表的第一个元素。
#+BEGIN_SRC lisp
  (car '(1 2 3 4 5))
; result 1
#+END_SRC
*** CDR 操作符 （别名 rest）
CDR 操作符和 CAR 的作用是相反的，它的作用是去除表的第一个元素。
#+BEGIN_SRC lisp
  (cdr '(1 2 3 4 5))
; result (2 3 4 5)
#+END_SRC
*** CXR 组合操作符
那么如何用这两个运算符取出第二个元素呢？
实际上，LISP 中由专门的操作符来表示这些操作，比如 CADR
#+BEGIN_SRC lisp
  (cadr '(1 2 3 4 5))
; result: 2
#+END_SRC
你也可以自己寻找更多类似的操作符。
** 第三章 构造表
*** CONS 操作符
CONS 操作符的作用是连接一个元素与一个表（顺序不可颠倒）
#+BEGIN_SRC lisp
  (cons 1 '(2 3))
; result (1 2 3)
#+END_SRC
*** S 表达式
CONS 操作符的第二个参数要是一个列表，才能返回一个列表。否则：
#+BEGIN_SRC lisp
  (cons 2 3)
; result (2 . 3)
#+END_SRC
这次中间有一个点。为什么呢？
在S 表达式中，二叉树表示为(Left . Right)。
如果左支是一个表，则就会成如下形式。
((List) . Right)
如果右分支是一个表，当然也可以表示为(Left . (List))，但是我们一般把点省略掉写成：
(Left List)
#+BEGIN_SRC lisp
  '(1 . (2 3))
; result (1 2 3)
#+END_SRC
CONS 操作符的实际作用是将两颗树连接成一棵树。
真正有点实质性的是这个例子：
#+BEGIN_SRC lisp
  (cons 1 (cons 2 (cons 3 nil)))
; result (1 2 3)
  '(3 . nil)
; result (3)
  (cdr '(3))
; result nil
#+END_SRC
*** append 函数
append 函数的作用是连接两个表。
#+BEGIN_SRC lisp
  (append '(3 3) '(4 4))
; result (3 3 4 4)
  (append '((3)) '(4 4))
; result ((3) 4 4)
#+END_SRC
要从现象去分析本质，通过二叉树的结构去分析，不难发现append函数的作用其实是
将后面的二叉树，插在了前面的二叉树最后一个叶子节点上，也就是 nil 节点。
*** LIST 函数
LIST 函数的意义是将所有的参数放入一个表中并返回。
#+BEGIN_SRC lisp
  (list 1 2 3 4)
; result (1 2 3 4)
  (list '(2 3) '(2) 1 2)
; result ((2 3) (2) 1 2)
#+END_SRC
结论：从结果上分析LIST 函数的实际作用就是将所有元素作为节点构造一个二叉树。
** 第四章 原子和值
*** 再讲原子
这次，我们愿意详细讲解原子。
原子可以是任何数，分数，小数，自然数，负数等等。
原子可以是一个字母排列，当然其中可以夹杂数字和符号。
空表就是原子NIL。

在 LISP 解释器中输入引用符（单引号）紧接着输入一个原子，可以返回这个原子本身，
就像对列表的操作一样。比如：
#+BEGIN_SRC lisp
  'sdf
; result sdf
#+END_SRC
但原子中还是不能包含一些特殊字符的，比如逗号：sdf, 。这个会返回错误 Error:
A comma has appered out of a backquote. 含义是，逗号出现在了单引号之外。

结论：不难分析出，原子就是二叉树的一个叶子节点。
*** ATOM 运算符
判断一个字符序列是不是原子，或者甚至一个元素是不是原子，我们用ATOM 运算符。
#+BEGIN_SRC lisp
  (atom 'a)
; result t
  (atom '(3))
; result nil
#+END_SRC
上面的第一个表达式返回 T，因为 a 是一个原子。而第二个表达式则返回 NIL，因为
(3) 是一个列表。 换言之， ATOM运算符在参数为原子时返回真，在参数为一个表时或
参数构不成原子时返回假。

结论：实际上是看是不是能构成一个叶子节点。
*** SETQ 运算符
首先来看一下：
#+BEGIN_SRC lisp
  1
; result 1
  a
; reslut Error: The variable A is unbound
#+END_SRC
很好，我们说过，解译器的功能就是对一个输入的表达式求值而已。1的值自然是1，
然而a的值呢，错误说变量A的值还未经绑定。绑定的意思就是类c语言中的赋值。

如何绑定一个变量呢，如下：
#+BEGIN_SRC lisp
  (setq a 5)
; reslut 5
#+END_SRC
然后，我们再次输入a，情形就不同了。
#+BEGIN_SRC lisp
  a
; reslut 5
#+END_SRC
不过，你肯定对输入(setq a 5)之后有一个5出现迷惑不解，setq运算符的意义就是
赋值并且将此值返回。就是说，表达式(setq a 5)的值是5 。

我们可以接着
#+BEGIN_SRC lisp 
  (setq a 6)
;reslut 6
  (cons a '(3))
;reslut (6 3)
#+END_SRC
现在这样也是可以的：
#+BEGIN_SRC lisp
  (setq a 'b)
;reslut b
  (cons a '(3))
;reslut (b 3)
  (setq a '(1 2 3))
;reslut (1 2 3)
  (setq b a)
;reslut (1 2 3)
  (cdr b)
;reslut (2 3)
#+END_SRC

结论：将一个二叉树的节点绑定到一个符号(变量名)上。
** 第五章 断言函数
*** ATOM 函数
前面已经讲过，用来判断一个表达式是不是原子。
*** NULL 函数
NULL 函数来判断表达式的值是不是NIL。
#+BEGIN_SRC lisp
  (null nil)
; reslut t
  (null (cdr '(3)))
; reslut t
  (null (car '(3)))
; reslut nil
  (null (+ 2 3 4 5))
; reslut nil
结论：没啥可解释的，判断一个二叉树的值是不是空。
#+END_SRC
*** EQUAL 函数
用来判断两个表达式的值是否完全相等。
#+BEGIN_SRC lisp
  (equal (+ 2 4) (* 2 3))
; reslut t
  (equal (cdr '(1 2 3)) '(2 3))
; reslut t
#+END_SRC
** 第六章 自己定义函数
*** DEFUN 操作符
DEFUN 操作符用来自定义函数，形势如下
(defun 函数名原子 参数名列表 执行列表)
比如：
#+BEGIN_SRC lisp
  (defun 2nd (x)
    (car (cdr x))
    )
; reslut 2nd
  (2nd '(1 2 3))
; reslut 2
#+END_SRC
*** 参数
参数就是我们第一个定义中的x，参数的个数是没有限制的。比如：
#+BEGIN_SRC lisp
  (defun lianjie (x y z)
    (append x y z)
    )
; result lianjie
(lianjie '(1 2) '(3 4) '(5 6))
; result (1 2 3 4)
#+END_SRC
*** 系统自带的函数
系统自带了很多函数，比如下面这两个函数：
**** first 函数
car的别名。
**** last 函数
last 函数的作用就是返回参数列表的最后一个元素所组成的表。
#+BEGIN_SRC lisp
  (last '(1 (2 3)))
; result ((2 3))
  (last '((((1 2) 3 4 ) 5) 6))
; result (1)
#+END_SRC
返回列表的最后一个元素然后组成表返回。

结论：为什么组成列表返回，因为是寻找二叉树的最“Right”的一个分支节点！
*** 第一个自定义函数
我们将要定义一个函数 ends，它的作用是返回参数列表的头尾两个元素组成的列表。
如何实现呢，我们首先取出参数列表的第一个元素，然后取出最后一个元素，再将两
者连在一起就行了。这要用到我们之前提到的 first 函数和 last 函数。
#+BEGIN_SRC lisp
  (defun ends (x) 
    (cons (first x) (last x))
    )
; result ends
  (ends '(1 2 3 4 5))
; result (1 5)
#+END_SRC
上面的这个例子中，关键的一步相当于 (cons 1 '(5)) 。

这样，我们就定义完成了这个函数。分析一下定义体中的 (cons (first x) (last x))
这是要连接两个元素，第一个元素是 x 的第一个元素，第二个元素是 last 函数所取出
的表。其结果自然就是x的头和尾两个元素所组成的列表。
