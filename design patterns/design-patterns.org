* 六大设计原则
** 单一职责原则 SRP (Single Responsibility Principle)
   There should never be more than one reason for a class to change.
*** RBAC (Role-Based Access Control) 基于角色的访问控制
*** BO (Bussiness Object) 业务对象
*** Biz (Bussiness Logic) 业务逻辑
*** 对于接口，在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑。
*** 对于类的单一职责
    This is sometimes hard to see.
** 里氏替换原则 LSP (Liskov Substitution Principle)
** 依赖倒置原则 DIP (Dependence Inversion Principle)
*** 面向接口编程 OOD (Object-Oriented Design)
** 接口隔离原则 
** 迪米特法则 LoD (Law of Demeter) LKP (Least Knowledge Principle)
** 开闭原则

* 设计模式
** 创建型模式
*** ABSTRACT FACTORY (抽象工厂) -- 对象创建型模型
**** 意图
     提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
**** 别名
     Kit
**** TODO 动机
**** 适用性
     在以下情况可以使用Abstract Factory模式。
***** 一个系统要独立于它的产品的创建、组合和表示时。
***** 一个系统要由多个产品系列中的一个来配置时。
***** 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
***** 当你提供一个产品类库，而只想显示它们的接口而不是实现时。
**** TODO 结构
     此模式的结构如下图所示。
**** TODO 参与者
**** TODO 协作
**** TODO 效果
**** TODO 实现
**** TODO 代码示例
**** 已知应用
**** 相关模式
*** BUILDER (生成器) -- 对象创建型模型
**** 意图
     将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
**** 动机
**** 适用性
     在以下情况适用Builder模式。
***** 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
***** 当构造过程必须允许被构造的对象有不同的表示时。
*** FACTROY METHOD (工厂方法) -- 对象创建模式
**** 意图
     定义一个用于创建对象的接口，让子类决定实例化哪一个类。
     Factory Method使一个类的实例化延迟到其子类。
**** 别名
     虚拟构造器 (Virtual )
**** 动机
*** PROTOTYPE (原型) -- 对象创建型模式
**** 意图
     用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
**** 动机
*** SINGLETON (单件) -- 对象创建型模式
**** 意图
     保证一个类仅有一个实例，并提供一个访问它的全局访问点。
**** 动机
**** 适用性
     在下面的情况下可以使用Singleleton模式
***** 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
***** 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。
** 结构型模式
*** ADAPTER (适配器) -- 类对象结构型模式
*** BRIDGE (桥接) -- 对象结构型模式
**** 意图
     将抽象部分与它的实现部分分离，使它们都可以独立地变化。
**** 别名
     Handle/Body
**** TODO 动机
*** COMPOSITE (组合) -- 对象结构型模式
**** 意图
     将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。
**** TODO 动机
*** DECORATOR (装饰) -- 对象结构型模式
**** 意图
     动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。
**** 别名
     包装器Wrapper
*** FACADE (外观) -- 对象结构型模式
**** 意图
     为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
*** FLYWEIGHT (享元) -- 对象结构型模式
**** 意图
     运用共享技术有效地支持大量细粒度的对象。
**** TODO 动机
*** PROXY (代理) -- 对象结构型模式
**** 意图
     为其他对象提供一种代理以控制对这个对象的的访问。
**** 别名
     Surrogate
**** TODO 动机
** 行为模式
*** CHAIN OF RESPONSIBILITY (职责链) -- 对象行为型模式
**** 意图
     使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
**** 动机
*** COMMAND (命令) -- 对象行为型模式
**** 意图
     将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销操作。
**** 别名
     动作(ACTION)，事物(Transaction)
*** INTERPRETER (解释器) -- 类行为型模式
**** 意图
     给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
*** ITERATOR (迭代器) -- 对象行为模式
**** 意图
     提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。
**** 别名
     游标(Cursor)。
*** MEDIATOR (中介者) -- 对象行为型模式
**** 意图
     用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
**** TODO 动机
*** MEMENTO (备忘录) -- 对象行为型模式
**** 意图
     在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
**** 别名
     Token
**** 动机
*** OBSERVER (观察者) -- 对象行为型模式
**** 意图
     定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
**** 别名
     依赖(Dependents),发布-订阅(Publish-Subscribe)
**** 动机
*** STATE (状态) -- 对象行为型模式
**** 意图
     允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
**** 别名
     状态对象(Objects for States)
**** 动机
*** STRATEGY (策略) -- 对象行为型模式
**** 意图
     定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
**** 别名
     政策 (Policy)
*** TEMPLATE METHOD (模板方法) -- 类行为型模式
**** 意图
     定义一个操作中的算法股价，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
**** 动机
*** VISITOR (访问者) -- 对象行为型模式
**** 意图
     表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
